<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Powergraph history</title>
    <!--[if IE]><script type="text/javascript" src="excanvas.js"></script><![endif]-->
  </head>
  <body>
    <h1>Powergraph history</h1>
    <div id="graph"></div>
    <div>Click+drag mouse on graph to pan and zoom.</div>
    <div><input id="fixbox" type="checkbox">Fix vertical scale</div>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="jquery.flot.js"></script>
    <script type="text/javascript">
    /*global jQuery:false, $:false */
    /*jslint whitespace:false, indent:4, onevar:false, browser:true */
    var width = 800;
    var height = 400;
    var minuteData = [];
    var hourData = [];
    var rawData = [];
    var startTime, endTime;
    $(function () {
        var options = {
                lines: { show: true },
                xaxis: { mode: 'time' },
                yaxis: {
		    min : 0,
                    tickFormatter: function (val, axis) {
                        return val.toFixed(axis.tickDecimals);
                    }
                },
                colors: [ 'red' ]
            },
            data,
            graph = $('#graph'),
	    fixbox = document.getElementById("fixbox"),
            timezoneOffset = (new Date()).getTimezoneOffset() * 60000,
	    mouse_active = false, mouse_zoom = false, mouse_pan = false,
	    mouse_activex, mouse_activey, time_origin, time_width,
            h_mmove, h_mdown, h_mstop, setHandlers,
	    fixVertical,
	    checkFetch, startFetch, dataGot, mergeData, tryMergeChunks,
	    fetching = false, needRedraw = false,
	    getScale, getDataSet, scheduleRedraw, doRedraw,
	    maxY = 0;
        endTime = (new Date()).getTime();
        startTime = endTime - 86400*0.25*1000;
	graph.width(width);
	graph.height(height);

	fixbox.onchange = function() {
	    fixVertical = fixbox.checked;
	    scheduleRedraw();
	};
	fixVertical = fixbox.checked;

	h_mmove = function(ev) {
	    var off = graph.offset();
	    var x = ev.pageX - off.left;
	    var y = ev.pageY - off.top;
	    if (mouse_active) {
		var dx = x - mouse_activex;
		var dy = y - mouse_activey;
		if (!mouse_zoom && !mouse_pan) {
		    var ax = Math.abs(dx);
		    var ay = Math.abs(dy);
		    if (ay >= 15 && ax <= ay/2)
			mouse_zoom = true;
		    else if (ax >= 15)
			mouse_pan = true;
		}
		if (mouse_zoom) {
		    var adj = Math.exp(dy/height*2.7);
		    var newWidth = time_width*adj;
		    var mid = (startTime+endTime)/2;
		    startTime = Math.round(mid - newWidth/2);
		    endTime = Math.round(mid + newWidth/2);
		    checkFetch();
		    scheduleRedraw();
		}
		if (mouse_pan) {
		    startTime = Math.round(time_origin - dx/width*time_width);
		    endTime = Math.round(startTime + time_width);
		    checkFetch();
		    scheduleRedraw();
		}
	    }
	};
	h_mdown = function(ev) {
	    var off = graph.offset();
	    var x = ev.pageX - off.left;
	    var y = ev.pageY - off.top;
	    mouse_active = true;
	    mouse_activex = x;
	    mouse_activey = y;
	    time_origin = startTime;
	    time_width = endTime - startTime;
	}
	h_mstop = function(ev) {
	    mouse_active = false;
	    mouse_zoom = false;
	    mouse_pan = false;
	}
	setHandlers = function(p, obj) {
	    obj.mousemove(h_mmove);
	    obj.mousedown(h_mdown);
	    obj.mouseup(h_mstop);
	    obj.mouseleave(h_mstop);
	}
	options["hooks"] = { bindEvents: [setHandlers] };

	checkFetch = function() {
	    var i, d;

	    if (fetching)
		return;
	    if (startTime >= endTime) {
		console.log("Ouch, startTime " + startTime + " >= endTime " + endTime);
		return;
	    }
	    d = getDataSet();

	    // Check for empty existing data.
	    if (d.length == 0)
		return startFetch(d, startTime, endTime);
	    // Check if we are at the very start of already fetched data.
	    if (startTime < d[0].a)
		return startFetch(d, startTime, Math.min(endTime, d[0].a));
	    // Find the first hole that overlaps, if any.
	    for (i = 0; i < d.length-1; ++i) {
		var t1 = d[i].b;
		var t2 = d[i+1].a;
		if (t1 == t2) {
		    // No hole here, just not merged chunks.
		    continue;
		}
		if (t1 > t2) {
		    // Just a sanity check.
		    console.log("Ouch, out-of-order @ " + i + ": " + t1 + " > " + t2);
		    return;
		}
		if (endTime <= t1) {
		    // This hole is beyond our interval, so we are done.
		    return;
		}
		if (t2 <= startTime) {
		    // This hole is too early, continue looking.
		    continue;
		}
		// This hole overlaps, so fetch the relevant part of it.
		return startFetch(d, Math.max(startTime, t1), Math.min(endTime, t2));
	    }
	    // Check if we need to fetch at the end of current data.
	    if (d[d.length-1].b < endTime)
		return startFetch(d, Math.max(startTime, d[d.length-1].b), endTime);
	};

	startFetch = function(d, a, b) {
	    var geturl;

	    fetching = true;
	    if (d == hourData)
		geturl = '/hourly/';
	    else if (d == minuteData)
		geturl = '/minutely/';
	    else
		geturl = '/range/';
	    $.ajax({
		url: geturl + a.toString() + '/' + b.toString(),
		method: 'GET',
		dataType: 'json',
		success: function(values) { dataGot(d, a, b, values); },
		error: function() { fetching = false; }
	    });
	}

	dataGot = function(d, a, b, values) {
	    mergeData(d, a, b, values);
	    fetching = false;

	    // Schedule a new fetch if anything more needed.
	    setTimeout(function () { checkFetch(); }, 0);

	    // Schedule a redraw with the newly available data.
	    scheduleRedraw();
	};

	tryMergeChunks = function(d, i) {
	    var c1 = d[i];
	    var c2 = d[i+1];
	    if (c1.b != c2.a)
		return;
	    var data1 = c1.data;
	    var data2 = c2.data;
	    if ((data1.length > 2000 && data2.length > 0) ||
		(data2.length > 2000 && data1.length > 0)) {
		// Let's not merge to avoid a too large chunk.
		return;
	    }
	    // Merge d[i] with d[i+1].
	    c1.b = c2.b;
	    var j;
	    for (j = 0; j < data2.length; ++j) {
		if (data1.length > 0 && data2[j][0] == data1[data1.length-1][0])
		    continue;
		data1.push(data2[j]);
	    }
	    d.splice(i+1, 1);
	};

	mergeData = function(d, a, b, values) {
	    var i, j;

	    if (d == rawData) {
		// Convert the millisecond blip duration to watt-usage
		for (j = 0; j < values.length; ++j)
		{
		    values[j][2] = 3600e3/values[j][1];
		}
	    }

	    // Find the right spot to insert the new chunk.
	    for (i = 0; i < d.length; ++i) {
		if (d[i].a >= b)
		    break;
	    }
	    var data = [ ];
	    for (j = 0; j < values.length; ++j) {
		data.push([values[j][0], values[j][2]]);
		if (values[j][2] > maxY)
		    maxY = values[j][2];
	    }
	    d.splice(i, 0, {a: a, b: b, data: data});

	    // Check if we should merge with the following chunk, and/or the prior.
	    if (i < d.length-1)
		tryMergeChunks(d, i);
	    if (i > 0)
		tryMergeChunks(d, i-1);
	};

	getScale = function() {
	    var delta = endTime - startTime;
	    if (delta / 3600e3 > width/4)
		return 2;
	    else if (delta / 60e3 > width/4)
		return 1;
	    else
		return 0;
	}

	getDataSet = function() {
	    var scale = getScale();
	    if (scale == 2)
		return hourData;
	    else if (scale == 1)
		return minuteData;
	    else
		return rawData;
	}

	scheduleRedraw = function () {
	    needRedraw = true;
	    setTimeout(function() {
		if (needRedraw) { doRedraw(); needRedraw = false; }
	    }, 0);
	};

	doRedraw = function() {
	    var i, j;
	    var x = [[startTime - timezoneOffset, undefined]];
	    var d = getDataSet();

	    for (i = 0; i < d.length; ++i) {
		if (d[i].a > endTime)
		    break;
		if (d[i].b < startTime)
		    continue;
		var data = d[i].data;
		for (j = 0; j < data.length; ++j) {
		    if (data[j][0] >= startTime && data[j][0] <= endTime) {
			if (x[x.length-1][1])
			    x.push([x[x.length-1][0], data[j][1]]);
			x.push([data[j][0] - timezoneOffset, data[j][1]]);
		    }
		}
	    }
	    x.push([x[x.length-1][0], undefined], [endTime - timezoneOffset, undefined]);

	    if (fixVertical)
		options.yaxis.max = maxY*1.10;
	    else
		options.yaxis.max = undefined;
	    $.plot(graph, [ x ], options);
	};

	checkFetch();
    });
    </script>
  </body>
</html>
