<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <title>Powergraph history</title>
    <!--[if IE]><script type="text/javascript" src="excanvas.js"></script><![endif]-->
  </head>
  <body>
    <h1>Powergraph history</h1>
    <div id="graph"></div>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="jquery.flot.js"></script>
    <script type="text/javascript">
    /*global jQuery:false, $:false */
    /*jslint whitespace:false, indent:4, onevar:false, browser:true */
    var width = 800;
    var height = 400;
    var minuteData = [];
    var hourData = [];
    var rawData = [];
    $(function () {
        var options = {
                lines: { show: true },
                xaxis: { mode: 'time' },
                yaxis: {
		    min : 0,
                    tickFormatter: function (val, axis) {
                        return val.toFixed(axis.tickDecimals);
                    }
                },
                colors: [ 'red' ]
            },
            data,
            graph = $('#graph'),
            timezoneOffset = (new Date()).getTimezoneOffset() * 60000,
	    mouse_active = false, mouse_zoom = false, mouse_pan = false,
	    mouse_activex, mouse_activey, time_origin, time_width,
            h_mmove, h_mdown, h_mstop, setHandlers,
	    checkFetch, startFetch, dataGot, mergeData,
	    fetching = false, needRedraw = false,
	    getScale, getDataSet, scheduleRedraw, doRedraw,
            endTime = (new Date()).getTime();
        var startTime = endTime - 86400*0.25*1000;
	graph.width(width);
	graph.height(height);

	h_mmove = function(ev) {
	    var off = graph.offset();
	    var x = ev.pageX - off.left;
	    var y = ev.pageY - off.top;
	    if (mouse_active) {
		var dx = x - mouse_activex;
		var dy = y - mouse_activey;
		if (!mouse_zoom && !mouse_pan) {
		    var ax = Math.abs(dx);
		    var ay = Math.abs(dy);
		    if (ay >= 15 && ax <= ay/2)
			mouse_zoom = true;
		    else if (ax >= 15)
			mouse_pan = true;
		}
		if (mouse_zoom) {
		    var adj = Math.exp(dy/height*2.7);
		    var newWidth = time_width*adj;
		    var mid = (startTime+endTime)/2;
		    startTime = Math.round(mid - newWidth/2);
		    endTime = Math.round(mid + newWidth/2);
		    checkFetch();
		    scheduleRedraw();
		}
		if (mouse_pan) {
		    startTime = Math.round(time_origin - dx/width*time_width);
		    endTime = Math.round(startTime + time_width);
		    checkFetch();
		    scheduleRedraw();
		}
	    }
	};
	h_mdown = function(ev) {
	    var off = graph.offset();
	    var x = ev.pageX - off.left;
	    var y = ev.pageY - off.top;
	    mouse_active = true;
	    mouse_activex = x;
	    mouse_activey = y;
	    time_origin = startTime;
	    time_width = endTime - startTime;
	}
	h_mstop = function(ev) {
	    mouse_active = false;
	    mouse_zoom = false;
	    mouse_pan = false;
	}
	setHandlers = function(p, obj) {
	    obj.mousemove(h_mmove);
	    obj.mousedown(h_mdown);
	    obj.mouseup(h_mstop);
	    obj.mouseleave(h_mstop);
	}
	options["hooks"] = { bindEvents: [setHandlers] };

	checkFetch = function() {
	    var i, d;

	    if (fetching)
		return;
	    d = getDataSet();
	    for (i = 0; i < d.length; ++i) {
		var a = d[i].a;
		var b = d[i].b;
		if (a > startTime) {
		    // The start of our interval is in a hole, need to fetch.
		    if (a <= endTime) {
			// Fetch up to next already fetched data
			return startFetch(d, startTime, a);
		    } else {
			// Fetch our whole interval
			return startFetch(d, startTime, endTime);
		    }
		} else {
		    if (b >= endTime) {
			// We already have everything, so done
			return;
		    } else if (b < startTime) {
			// Our interval is later than this point, try next one
			continue;
		    } else {
			// The end of our interval is in a hole, need to fetch
			if (i+1 < d.length && d[i+1].a <= endTime) {
			    // Fetch up to next already fetched data
			    return startFetch(d, b, d[i+1].a);
			} else {
			    // Fetch entire rest of interval
			    return startFetch(d, b, endTime);
			}
		    }
		}
	    }
	    // Interval is beyond what we already have, so need to fetch everything
	    return startFetch(d, startTime, endTime);
	};

	startFetch = function(d, a, b) {
	    var geturl;

	    fetching = true;
	    if (d == hourData)
		geturl = '/hourly/';
	    else if (d == minuteData)
		geturl = '/minutely/';
	    else
		geturl = '/range/';
	    $.ajax({
		url: geturl + a.toString() + '/' + b.toString(),
		method: 'GET',
		dataType: 'json',
		success: function(values) { dataGot(d, a, b, values); },
		error: function() { fetching = false; }
	    });
	}

	dataGot = function(d, a, b, values) {
	    fetching = false;
	    mergeData(d, a, b, values);

	    // Schedule a new fetch if anything more needed.
	    setTimeout(function () { checkFetch(); }, 0);

	    // Schedule a redraw with the newly available data.
	    scheduleRedraw();
	};

	mergeData = function(d, a, b, values) {
	    var i, j;

	    if (d == rawData) {
		// Convert the millisecond blip duration to watt-usage
		for (j = 0; j < values.length; ++j)
		{
		    values[j][2] = 3600e3/values[j][1];
		}
	    }

	    if (d.length == 0 || b < d[0].a) {
		var data = [ ];
		for (j = 0; j < values.length; ++j) {
		    data.push([values[j][0], values[j][2]]);
		}
		d.unshift({a: a, b: b, data: data});
		return;
	    }
	    for (i = 0; i < d.length; ++i) {
		if (d[i].a == b) {
		    d[i].a = a;
		    for (j = values.length-1; j >0; --j) {
			if (values[j][0] == d[i].data[0][0])
			    continue;
			d[i].data.unshift([values[j][0], values[j][2]]);
		    }
		    return;
		} else if (d[i].b == a) {
		    d[i].b = b;
		    for (j = 0; j < values.length; ++j) {
			if (values[j][0] == d[i].data[d.length-1][0])
			    continue;
			d[i].data.push([values[j][0], values[j][2]]);
		    }
		    return;
		} else if (a > d[i].b) {
		    var data = [ ];
		    for (j = 0; j < values.length; ++j) {
			data.push([values[j][0], values[j][2]]);
		    }
		    d.splice(i+1, 0, {a: a, b: b, data: data});
		    return;
		}
	    }
	};

	getScale = function() {
	    var delta = endTime - startTime;
	    if (delta / 3600e3 > width/4)
		return 2;
	    else if (delta / 60e3 > width/4)
		return 1;
	    else
		return 0;
	}

	getDataSet = function() {
	    var scale = getScale();
	    if (scale == 2)
		return hourData;
	    else if (scale == 1)
		return minuteData;
	    else
		return rawData;
	}

	scheduleRedraw = function () {
	    needRedraw = true;
	    setTimeout(function() {
		if (needRedraw) { doRedraw(); needRedraw = false; }
	    }, 0);
	};

	doRedraw = function() {
	    var i, j;
	    var x = [[startTime - timezoneOffset, undefined]];
	    var d = getDataSet();

	    for (i = 0; i < d.length; ++i) {
		if (d[i].a > endTime)
		    continue;
		if (d[i].b < startTime)
		    break;
		var data = d[i].data;
		for (j = 0; j < data.length; ++j) {
		    if (data[j][0] >= startTime && data[j][0] <= endTime) {
			if (x[x.length-1][1])
			    x.push([x[x.length-1][0], data[j][1]]);
			x.push([data[j][0] - timezoneOffset, data[j][1]]);
		    }
		}
	    }
	    x.push([x[x.length-1][0], undefined], [endTime - timezoneOffset, undefined]);

	    $.plot(graph, [ x ], options);
	};

	checkFetch();
    });
    </script>
  </body>
</html>
